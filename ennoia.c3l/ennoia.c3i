
module ennoia;

extern double  deltaTime    @extern("deltatime");
extern double  lastFrame    @extern("lastframe");
extern bool    forceClose   @extern("forceclose");
extern Vector2 mousPosition @extern("mouseposition");
extern float   scrollwheel  @extern("scrollwheel");

extern fn void init(int width = -1, int height = -1, String title = "ENNOIA", float scale = 0) @extern("init");
extern fn void clean() @extern("clean");
extern fn bool window_should_close() @extern("windowshouldclose");
extern fn void set_vertex_attribute(uint location, uint size, void* offset) @extern("set_vertex_attribute");

extern fn void start_drawing() @extern("start_drawing");
extern fn void end_drawing() @extern("end_drawing");

extern fn void clear_background() @extern("clearbg");
extern fn void set_Size(uint w, uint h) @extern("setsize");
extern fn void set_render_scale(float scale) @extern("setrenderscale");
extern fn void set_borderless(bool borderless = true) @extern("setborderless");
extern fn void set_fullscreen(bool fullscreen = true) @extern("setfullscreen");
extern fn void set_fov(float fov) @extern("setfov");
extern fn int get_fps() @extern("getfps");
extern fn int[2] get_display_resolution() @extern("getdisplayresolution");

extern fn void set_shader(Shader newShader) @extern("setshader");
extern fn Shader get_shader() @extern("getshader");


module ennoia::render;
import ennoia::color;
import ennoia::rectangle;
import ennoia::vector;

extern fn void draw_mesh(String nameMesh = "cube", String nameTexture = "", Vector3 position = {}, Vector3 scale = {1,1,1}, Vector3 rotation = {}) @extern("render_mesh");
extern fn void draw_texture(String nameTexture = "default", Rectangle dst = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, Vector3 rotation = {}, Color tint = {255, 255, 255, 255}) @extern("render_texture");


module ennoia::bounds;
import ennoia::vector;

struct BoundingBox {
  Vector3 min, max;
}

extern fn bool check_boxes(BoundingBox b1, BoundingBox b2) @extern("bounds_checkbox");


module ennoia::bulk;
import ennoia::font;
import ennoia::keybinds;
import ennoia::localization;
import ennoia::mesh;
import ennoia::options;
import ennoia::shader;
import ennoia::texture;
import std::collections;
import std::io;

extern const char VERSION_MAJOR @extern("bulk_majorversion");
extern const char VERSION_MINOR @extern("bulk_minorversion");

alias BulkTable = HashMap{String, TableEntry};
struct TableEntry {
  String name;
  ulong length, pointer;
  DataType type;
CompType comp;
}
enum DataType : short {
  EMPTY,
  RAW,
  TEXT,
  KEYBIND,
  OPTION,
  LOCALIZATION,
  
  // OpenGL/SDL3
  TEXTURE,
  FONT,
SHADER,
  MODEL,
  MATERIAL,
}
enum CompType : short {
  NONE,
  DEFLATE,
}

extern fn char[]  load(String filepath, String dataname) @extern("bulk_load");
extern fn void    load_all(String filepath) @extern("bulk_loadall");
extern fn Texture load_texture(String filepath, String dataname, bool send = true) @extern("bulk_texture");
extern fn void    load_all_textures(String filepath) @extern("bulk_alltextures");
extern fn Font    load_font(String filepath, String dataname, bool send = true) @extern("bulk_font");
extern fn void    load_all_font(String filepath) @extern("bulk_allfont");
extern fn HashMap{String, Mesh} load_model(String filepath, String dataname, bool send = true) @extern("bulk_model");
extern fn void    load_all_models(String filepath) @extern("bulk_allmodel");
extern fn Shader  load_shader(String filepath, String dataname, bool send = true) @extern("bulk_shader");
extern fn void    load_all_shaders(String filepath) @extern("bulk_allshader");
extern fn Keybind load_keybind(String filepath, String dataname, bool send = true) @extern("bulk_keybind");
extern fn void    load_all_keybinds(String filepath) @extern("bulk_allkeybind");
extern fn Option  load_option(String filepath, String dataname, bool send = true) @extern("bulk_option");
extern fn void    load_all_options(String filepath) @extern("bulk_alloption");
extern fn Localization load_localization(String filepath, String dataname, bool send = true) @extern("bulk_local");
extern fn void    load_all_localizations(String filepath) @extern("bulk_alllocal");

extern fn bool TableEntry.equals_str(&self, String rhs) @operator_s(==) @extern("tableentry_equals");
extern fn usz TableEntry.size(&self) @extern("tableentry_size");

extern fn String[] get_entries(String filepath) @extern("tableentry_getentries");
extern fn BulkTable get_table(String filepath) @extern("tableentry_gettable");
extern fn TableEntry get_table_entry(String filepath, String dataname) @extern("tableentry_gettableentry");

extern fn short File.read_short(&self) @extern("bulk_fileshort");
extern fn int File.read_int(&self) @extern("bulk_fileint");
extern fn long File.read_long(&self) @extern("bulk_filelong");
extern fn float File.read_float(&self) @extern("bulk_filefloat");
extern fn double File.read_double(&self) @extern("bulk_filedouble");
extern fn String File.read_string(&self) @extern("bulk_filestring");

extern fn void File.write_short(&self, short val) @extern("bulk_filewriteshort");
extern fn void File.write_int(&self, int val) @extern("bulk_filewriteint");
extern fn void File.write_long(&self, long val) @extern("bulk_filewritelong");
extern fn void File.write_float(&self, float val) @extern("bulk_filewritefloat");
extern fn void File.write_double(&self, double val) @extern("bulk_filewritedouble");
extern fn void File.write_string(&self, String val) @extern("bulk_filewritestring");


module ennoia::camera;
import ennoia::matrix;
import ennoia::vector;

struct Camera {
  Vector3 target, distance, up;
  float fov, rotation, rot_target;
}

extern Camera main @extern("camera_main");

extern fn void update(Camera* cam = &main) @extern("camera_update");
extern fn Matrix get_matrix(Camera* cam = &main) @extern("camer_getmatrix");
extern fn void rotate(float target, Camera* cam = &main) @extern("camera_rotate");
extern fn bool is_rotating(Camera* cam = &main) @extern("camera_isrotating");
extern fn void Camera.print(self) @extern("camera_print");


module ennoia::color;
import ennoia::vector;

struct Color {
  char r, g, b, a;
}

extern fn bool Color.equals(self, Color rhs) @operator(==) @extern("color_equals");

extern fn uint Color.to_int(self) @extern("color_toint");
extern fn Color uint.to_color(self) @extern("color_fromint");
extern fn Vector3 Color.to_hsv(self) @extern("color_tohsv");
extern fn Color Vector3.to_color(self) @extern("colorfromhsv");
extern fn Vector4 Color.normalize(self) @extern("color_normalize");

extern fn void Color.fade(&self, float alpha) @extern("color_fade");
extern fn Color Color.tint(self, Color tint) @extern("color_tint");
extern fn Color Color.brightness(self, float factor) @extern("color_brightness");
extern fn Color Color.contrast(self, float contrast) @extern("color_contrast");
extern fn Color Color.alpha(self, float alpha) @extern("color_alpha");
extern fn Color Color.multiply(self, float factor) @extern("color_multiply");


module ennoia::font;
import ennoia::color;
import ennoia::rectangle;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Font {
  Texture atlas;
  Vector2 dim;
  HashMap{char, Rectangle} rects;
}

extern fn Font load(String filename, Vector2 size) @extern("font_load");
extern fn Font load_from_mem(char[] data, Vector2 size) @extern("font_loadfrommem");
extern fn void Font.clean(&self) @extern("font_clean");

extern fn void Font.draw(&self, String textIn, Vector2 position = {0,0}, Vector2 scale = {1,1}, float spacing = 0, Color color = color::WHITE) @extern("font_draw");


module ennoia::keybinds;
import std::collections;
import sdl3;

alias KeyboardKey = uint;
alias KeyboardMod = ushort;
alias Keybindings = HashMap{String, Keybind};

struct KeyData {
  KeyboardKey key;
  KeyboardMod mod;
  bool down;
  bool repeat;
}
struct Keybind {
  KeyboardKey key;
  KeyboardMod mod;
}

extern fn void save_keybinds() @extern("keybinds_save");
extern fn void KeyData.print(&self) @extern("keybinds_print");

extern fn void update() @extern("keybinds_update");

extern fn int  queue_contains(SDL_KeyboardEvent data) @export("keybinds_queuecontains");
extern fn void queue_add(SDL_KeyboardEvent data) @extern("keybinds_queueadd");
extern fn void queue_remove(SDL_KeyboardEvent data) @extern("keybinds_queueremove");

extern fn bool pressed(String key) @extern("keybinds_pressed");
extern fn bool down(String key)    @extern("keybinds_down");
extern fn bool up(String key)      @extern("keybinds_up");
extern fn bool mouse_pressed(String key) @extern("keybinds_mousepressed");
extern fn bool mouse_down(String key)    @extern("keybinds_mousedown");
extern fn bool mouse_up(String key)      @extern("keybinds_mouseup");


module ennoia::localization;
import std::collections;

alias Local = HashMap{String, String};
alias Localization = HashMap{String, Local};

extern fn void Localization.add_assign(&self, Localization* rhs) @operator(+=) @extern("local_add");

extern fn String get(String key) @extern("local_get");
extern fn bool contains(String key) @extern("local_contains");


module ennoia::matrix;
import ennoia::vector;

struct Matrix {
  float m0,  m1,  m2,  m3;
  float m4,  m5,  m6,  m7;
  float m8,  m9,  m10, m11;
  float m12, m13, m14, m15;
}

const Matrix IDENTITY = {
  1,0,0,0,
  0,1,0,0,
  0,0,1,0,
  0,0,0,0,
};

extern fn bool Matrix.equals(self, Matrix rhs) @operator(==) @extern("matrix_equals");
extern fn Matrix Matrix.add(self, Matrix rhs) @operator(+) @extern("matrix_add");
extern fn Matrix Matrix.sub(self, Matrix rhs) @operator(-) @extern("matrix_sub");
extern fn Matrix Matrix.mul(self, Matrix rhs) @operator(*) @extern("matrix_mul");

extern fn float Matrix.determinant(self) @extern("matrix_determinant");
extern fn float Matrix.trace(self) @extern("matrix_trace");
extern fn Matrix Matrix.transpose(self) @extern("matrix_transpose");
extern fn Matrix Matrix.invert(self) @extern("matrix_invert");
extern fn Vector4 Matrix.quaternion_transform(self, Quaternion q) @extern("matrix_quaterniontransform");
extern fn void Matrix.print(&self) @extern("matrix_print");
extern fn Matrix Matrix.translate(self, Vector3 v) @extern("matrix_translate");
extern fn Matrix rotate_x(float angle) @extern("matrix_rotatex");
extern fn Matrix rotate_y(float angle) @extern("matrix_rotatey");
extern fn Matrix rotate_z(float angle) @extern("matrix_rotatez");
extern fn Matrix Matrix.rotate(&self, Vector3 angle) @extern("matrix_rotatexyz");
extern fn Matrix rotate_zyx(Vector3 angle) @extern("matrix_rotatezyx");
extern fn Matrix Matrix.scale(self, Vector3 scale) @extern("matrix_scale");
extern fn Matrix frustum(double left, double right, double bottom, double top, double near_plane, double far_plane) @extern("matrix_frustum");
extern fn Matrix perspective(double fov_y, double aspect, double near_plane, double far_plane) @extern("matrix_perspective");
extern fn Matrix ortho(double left, double right, double bottom, double top, double near_plane, double far_plane) @extern("matrix_");
extern fn Matrix look_at(Vector3 eye, Vector3 target, Vector3 up) @extern("matrix_lookat");


module ennoia::mesh;
import ennoia::matrix;
import ennoia::shader;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Mesh {
  Vertex[] vertices;
  Indices[] indices;

  uint vao, vbo, ebo;

  Shader shader;
  String materialName;
  Texture* texture;
}

struct Vertex {
  Vector3 position;
  Vector3 normal;
  Vector2 texCoords;
  Vector4 color;
}
alias Indices = uint[3];

extern fn HashMap{String, Mesh} load_from_mem(String data) @extern("mesh_loadfrommem");
extern fn void Mesh.clean(&self) @extern("mesh_cleanmesh");

extern fn Mesh new(Vertex[] vertices = {}) @extern("mesh_new");
extern fn Mesh gen_tri(float width, float height) @extern("mesh_gentri");
extern fn Mesh gen_quad() @extern("mesh_genquad");
extern fn Mesh gen_cube(float width, float height, float depth) @extern("mesh_gencube");

extern fn void Mesh.upload(&self) @extern("mesh_upload");
extern fn void Mesh.delete(&self) @extern("mesh_delete");

extern fn void Mesh.update_positions(&self, Vector3[] newPos) @extern("mesh_updatepositions");
extern fn void Mesh.update_normals(&self, Vector3[] newNorms) @extern("mesh_updatenormals");
extern fn void Mesh.update_texcoords(&self, Vector2[] newCoords) @extern("mesh_updatetexcoords");
extern fn void Mesh.update_colors(&self, Vector4[] newColors) @extern("mesh_updatecolors");

extern fn void Mesh.draw(&self, Vector3 position = {}, Vector3 scale = {1,1,1}, Vector3 rotation = {}, Texture* texture = null) @extern("mesh_draw");
extern fn void Mesh.draw_instanced(&self, Matrix[] mats) @extern("mesh_drawinstanced");
extern fn void Mesh.draw_2d(&self, Vector2 position = {}, Vector2 scale = {1,1}, float rotation = 0, Texture* texture = null) @extern("mesh_draw2d");

extern fn void Vertex.print(&self) @extern("mesh_print");


module ennoia::options;
import std::collections;

alias Options = HashMap{String, Option};

struct Option {
  OptionType type;
  OptionData data;
}
union OptionData {
  char as_char;
  short as_short;
  int as_int;
  long as_long;

  float as_float;
  double as_double;

  String as_string;
}
enum OptionType : char {
  CHAR,
  SHORT,
  INT,
  LONG,

  FLOAT,
  DOUBLE,

  STRING,
}

extern fn char get_char(String optname) @extern("options_char");
extern fn short get_short(String optname) @extern("options_short");
extern fn int get_int(String optname) @extern("options_int");
extern fn long get_long(String optname) @extern("options_long");
extern fn float get_float(String optname) @extern("options_float");
extern fn double get_double(String optname) @extern("options_double");

extern fn void set_char(String optname) @extern("options_setchar");
extern fn void set_short(String optname) @extern("options_setshort");
extern fn void set_int(String optname) @extern("options_setint");
extern fn void set_long(String optname) @extern("options_setlong");
extern fn void set_float(String optname) @extern("options_setfloat");
extern fn void set_double(String optname) @extern("options_setdouble");

extern fn bool contains(String optname) @extern("options_contains");

extern fn void save() @export("options_save");


module ennoia::rectangle;
import ennoia::vector;

struct Rectangle {
  float x, y, w, h;
}

extern fn bool Rectangle.equals(self, Rectangle rhs) @operator(==) @extern("rect_equals");
extern fn Rectangle Rectangle.add(self, Rectangle rhs) @operator(+) @extern("rect_add");
extern fn Rectangle Rectangle.add_v2(self, Vector2 rhs) @operator_s(+) @extern("rect_addv2");
extern fn Rectangle Rectangle.add_v4(self, Vector4 rhs) @operator_s(+) @extern("rect_addv4");
extern fn Rectangle Rectangle.sub(self, Rectangle rhs) @operator(-) @extern("rect_sub");
extern fn Rectangle Rectangle.sub_v2(self, Vector2 rhs) @operator_s(-) @extern("rect_subv2");
extern fn Rectangle Rectangle.mul(self, Rectangle rhs) @operator(*) @extern("rect_mul");
extern fn Rectangle Rectangle.mul_v2(self, Vector2 rhs) @operator_s(*) @extern("rect_mulv2");
extern fn Rectangle Rectangle.div(self, Rectangle rhs) @operator(/) @extern("rect_div");
extern fn Rectangle Rectangle.div_v2(self, Vector2 rhs) @operator_s(/) @extern("rect_divv2");

extern fn Vector2 Rectangle.v2(self) @extern("rect_v2");
extern fn Vector4 Rectangle.v4(self) @extern("rect_v4");

extern fn bool Rectangle.within(self, Vector2 rhs) @extern("rect_within");


module ennoia::shader;
import ennoia::matrix;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Shader {
  uint id;
  HashMap{String,uint} locs;
}

extern fn Shader load(String vert, String frag) @extern("shader_load");
extern fn Shader compile(char[] vert = {}, char[] frag = {}) @extern("shader_compile");
extern fn void Shader.clean(&self) @extern("shader_clean");
extern fn void Shader.use(&self) @extern("shader_use");

extern fn void Shader.set_int(&self, String name, int i) @extern("shader_setint");
extern fn void Shader.set_float(&self, String name, float f) @extern("shader_setfloat");
extern fn void Shader.set_vector2(&self, String name, Vector2 v2) @extern("shader_setv2");
extern fn void Shader.set_matrix(&self, String name, Matrix mat) @extern("shader_setmat");
extern fn void Shader.set_texture(&self, String name, Texture texture) @extern("shader_settexture");


module ennoia::texture;
import ennoia::color;
import ennoia::rectangle;

struct Texture {
  uint id;
  uint width, height;
  int mipmaps;
  int format;
  bool transparency;
}
enum TilingLayout {
  THREE_THREE,
  ONE_THREE,
  THREE_ONE,
}

extern fn Texture load(String filename) @extern("texture_load");
extern fn Texture load_from_mem(char[] dat) @extern("texture_loadfrommem");
extern fn Texture new(int width, int height) @extern("texture_new");
extern fn void Texture.clean(&self) @extern("texture_clean");

extern fn void Texture.draw(&self, Rectangle dst = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, Color color = color::WHITE) @extern("texture_draw");
extern fn void Texture.draw_tiled(&self, Rectangle dest = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, TilingLayout layout = THREE_THREE, Color color = color::WHITE) @extern("texture_drawtiled");


module ennoia::ui;
import ennoia::color;
import ennoia::rectangle;
import ennoia::vector;

alias Element = void;
alias FuncCallVoid = fn void();
enum ElementType {
  EMPTY,

  LABEL,
  BUTTON,
  BAR,

  CONTAINER_VERT,
  CONTAINER_HORI,
}
enum TextAlignmentHorizontal {
  RIGHT,
  CENTER,
  LEFT,
}
enum TextAlignmentVertical {
  TOP,
  CENTER,
  BOTTOM,
}

extern fn void add(String name, Element* e) @extern("ui_add");
extern fn bool exists(String name) @extern("ui_exists");
extern fn Element* get(String name) @extern("ui_get");

extern fn Element* new_label(String text = "NULL", long duration = 0, String font = "font", float spacing = 0, Color tint = color::WHITE, Vector2 position = {0,0}, Vector2 scale = {1,1}) @extern("ui_label");
extern fn Element* new_button(String text = "NULL", long duration = 0, String font = "font", float spacing = 0, Color textTint = color::WHITE, String texture = "texture", Color[3] textureTint = {color::WHITE, color::LIGHTGRAY, color::DARKGRAY}, Rectangle bounds = {0,0,64,16}, Vector4 textPadding = {2,2,2,2}, Vector2 scale = {1,1}, TextAlignmentHorizontal alignHori = CENTER, TextAlignmentVertical alignVert = CENTER, bool active = true, FuncCallVoid hover = null, FuncCallVoid click = null) @extern("ui_button");
extern fn Element* new_container(ElementType container = CONTAINER_VERT, long duration = 0, Rectangle bounds = {0,0,16,16}, Vector2 scale = {1,1}, Vector4 offset = {2,2,2,2}, float spacing = 0, String texture = "", Element*[] elements = {}) @extern("ui_container");


module ennoia::vector;
import ennoia::color;
import ennoia::matrix;

struct Vector2 {
  float x, y;
}

extern fn bool Vector2.equals(self, Vector2 rhs) @operator(==) @extern("vector2_equals");
extern fn Vector2 Vector2.add(self, Vector2 rhs) @operator(+) @extern("vector2_add");
extern fn Vector2 Vector2.pos_offset(self, float rhs) @operator_s(+) @extern("vector2_pos_offset");
extern fn Vector2 Vector2.sub(self, Vector2 rhs) @operator(-) @extern("vector2_sub");
extern fn Vector2 Vector2.neg_offset(self, float rhs) @operator_s(-) @extern("vector2_neg_offset");
extern fn Vector2 Vector2.mul(self, Vector2 rhs) @operator(*) @extern("vector2_mul");
extern fn Vector2 Vector2.scale(self, float rhs) @operator_s(*) @extern("vector2_scale");
extern fn Vector2 Vector2.div(self, Vector2 rhs) @operator(/) @extern("vector2_div");
extern fn Vector2 Vector2.inverse(self, float rhs) @operator_s(/) @extern("vector2_inverse");

extern fn Vector3 Vector2.v3(self) @extern("vector2_v3");
extern fn Vector4 Vector2.v4(self) @extern("vector2_v4");
extern fn Quaternion Vector2.q(self) @extern("vector2_q");

extern fn float Vector2.length(self) @extern("vector2_length");
extern fn float Vector2.length_sqr(self) @extern("vector2_length_sqr");
extern fn float Vector2.dot_product(self, Vector2 v2) @extern("vector2_dot_product");
extern fn float Vector2.distance(self, Vector2 v2) @extern("vector2_distance");
extern fn float Vector2.distance_sqr(self, Vector2 v2) @extern("vector2_distance_sqr");
extern fn float Vector2.angle_rad(self, Vector2 v2) @extern("vector2_angle_rad");
extern fn float Vector2.angle_deg(self, Vector2 v2) @extern("vector2_angle_deg");
extern fn Vector2 Vector2.normalize(self) @extern("vector2_normalize");
extern fn Vector2 Vector2.transform(self, Matrix mat) @extern("vector2_transform");
extern fn Vector2 Vector2.lerp(self, Vector2 v2, float amount) @extern("vector2_lerp");
extern fn Vector2 Vector2.reflect(self, Vector2 normal) @extern("vector2_reflect");
extern fn Vector2 Vector2.rotate_rad(self, float angle) @extern("vector2_rotate_rad");
extern fn Vector2 Vector2.rotate_deg(self, float angle) @extern("vector2_rotate_deg");
extern fn Vector2 Vector2.move_towards(self, Vector2 target, float max_distance) @extern("vector2_move_toward");
extern fn Vector2 Vector2.invert(self) @extern("vector2_invert");
extern fn Vector2 Vector2.clamp(self, Vector2 min, Vector2 max) @extern("vector2_clamp");
extern fn Vector2 Vector2.clamp_mag(self, float min, float max) @extern("vector2_clamp_mag");


struct Vector3 {
  float x, y, z;
}

extern fn bool Vector3.equals(self, Vector3 rhs) @operator(==) @extern("vector3_equals");
extern fn Vector3 Vector3.add(self, Vector3 rhs) @operator(+) @extern("vector3_add");
extern fn Vector3 Vector3.pos_offset(self, float rhs) @operator_s(+) @extern("vector3_pos_offset");
extern fn Vector3 Vector3.sub(self, Vector3 rhs) @operator(-) @extern("vector3_sub");
extern fn Vector3 Vector3.neg_offset(self, float rhs) @operator_s(-) @extern("vector3_neg_offset");
extern fn Vector3 Vector3.mul(self, Vector3 rhs) @operator(*) @extern("vector3_mul");
extern fn Vector3 Vector3.scale(self, float rhs) @operator_s(*) @extern("vector3_scale");
extern fn Vector3 Vector3.div(self, Vector3 rhs) @operator(/) @extern("vector3_add");
extern fn Vector3 Vector3.inverse(self, float rhs) @operator_s(/) @extern("vector3_inverse");
extern fn Vector3 Vector3.remainder(self, int rhs) @operator(%) @extern("vector3_remainder");

extern fn Vector2 Vector3.v2(self) @extern("vector3_v2");
extern fn Vector4 Vector3.v4(self) @extern("vector3_v4");
extern fn Quaternion Vector3.q(self) @extern("vector3_q");
extern fn float[3] Vector3.to_array(self) @extern("vector3_farr");
extern fn int[3] Vector3.to_int_array(self) @extern("vector3_iarr");
extern fn Vector3 int[3].from_int_array(self) @extern("intarray_v3");
extern fn Color Vector3.color(self) @extern("vector3_color");

extern fn float Vector3.cross_product(self, Vector3 v2) @extern("vector3_cross_product");
extern fn float Vector3.perpendicular(self) @extern("vector3_perpendicular");
extern fn float Vector3.length(self) @extern("vector3_length");
extern fn float Vector3.length_sqr(self) @extern("vector3_legnth_sqr");
extern fn float Vector3.dot_product(self, Vector3 v2) @extern("vector3_dot_product");
extern fn float Vector3.distance(self, Vector3 v2) @extern("vector3_distance");
extern fn float Vector3.distance_sqr(self, Vector3 v2) @extern("vector3_distance_sqr");
extern fn float Vector3.angle_rad(self, Vector3 v2) @extern("vector3_angle_rad");
extern fn float Vector3.angle_deg(self, Vector3 v2) @extern("vector3_angle_deg");
extern fn Vector3 Vector3.normalize(self) @extern("vector3_normalize");
extern fn Vector3 Vector3.project(self, Vector3 v2) @extern("vector3_project");
extern fn Vector3 Vector3.reject(self, Vector3 v2) @extern("vector3_reject");
extern fn void Vector3.orthonormalize(&self, Vector3* v2) @extern("vector3_orthonormalize");
extern fn Vector3 Vector3.transform(self, Matrix mat) @extern("vector3_transform");
extern fn Vector3 Vector3.rotate_quaternion(self, Quaternion q) @extern("vector3_rotate_q");
extern fn Vector3 Vector3.rotate(self, Vector3 dist, float rot) @extern("vector3_rotate");
extern fn Vector3 Vector3.rotate_axis(self, Vector3 axis, float angle) @extern("vector3_rotate_axis");
extern fn Vector3 Vector3.move_towards(self, Vector3 target, float max_distance) @extern("vector3_move_towards");
extern fn Vector3 Vector3.lerp(self, Vector3 target, float amount) @extern("vector3_lerp");
extern fn Vector3 Vector3.reflect(self, Vector3 normal) @extern("vector3_reflect");
extern fn Vector3 Vector3.min(self, Vector3 v2) @extern("vector3_min");
extern fn Vector3 Vector3.max(self, Vector3 v2) @extern("vector3_max");
extern fn Vector3 Vector3.barycenter(self, Vector3 a, Vector3 b, Vector3 c) @extern("vector3_barycenter");
extern fn Vector3 Vector3.unproject(self, Matrix projection, Matrix view) @extern("vector3_unproject");
extern fn Vector3 Vector3.invert(self) @extern("vector3_invert");
extern fn Vector3 Vector3.clamp(self, Vector3 min, Vector3 max) @extern("vector3_clamp");
extern fn Vector3 Vector3.clamp_mag(self, float min, float max) @extern("vector3_clamp_mag");
extern fn Vector3 refract(Vector3 v, Vector3 n, float r) @extern("vector3_refract");
extern fn bool float.close(self, float f2, float amount) @extern("float_close");
extern fn bool Vector3.close(self, Vector3 v2, float amount) @extern("vector3_close");
extern fn void Vector3.print(self) @extern("vector3_print");


struct Vector4 {
  float x, y, z, w;
}

extern fn bool Vector4.equals(self, Vector4 rhs) @operator(==) @extern("vector4_equals");
extern fn Vector4 Vector4.add(self, Vector4 rhs) @operator(+) @extern("vector4_add");
extern fn Vector4 Vector4.pos_offset(self, float rhs) @operator_s(+) @extern("vector4_pos_offset");
extern fn Vector4 Vector4.sub(self, Vector4 rhs) @operator(-) @extern("vector4_sub");
extern fn Vector4 Vector4.neg_offset(self, float rhs) @operator_s(-) @extern("vector4_neg_offset");
extern fn Vector4 Vector4.mul(self, Vector4 rhs) @operator(*) @extern("vector4_mul");
extern fn Vector4 Vector4.scale(self, float rhs) @operator_s(*) @extern("vector4_scale");
extern fn Vector4 Vector4.mul_mat(self, Matrix rhs) @operator_s(*) @extern("vector4_mulmat");
extern fn Vector4 Vector4.div(self, Vector4 rhs) @operator(/) @extern("vector4_div");
extern fn Vector4 Vector4.inverse(self, float rhs) @operator_s(/) @extern("vector4_inverse");

extern fn Vector2 Vector4.v2(self) @extern("vector4_v2");
extern fn Vector3 Vector4.v3(self) @extern("vector4_v3");
extern fn Quaternion Vector4.q(self) @extern("vector4_q");
extern fn Color Vector4.color(self) @extern("vector4_color");

extern fn float Vector4.length(self) @extern("vector4_length");
extern fn float Vector4.length_sqr(self) @extern("vector4_length_sqr");
extern fn float Vector4.dot_product(self, Vector4 v2) @extern("vector4_dot_product");
extern fn float Vector4.distance(self, Vector4 v2) @extern("vector4_distance");
extern fn float Vector4.distance_sqr(self, Vector4 v2) @extern("vector4_distance_sqr");
extern fn Vector4 Vector4.normalize(self) @extern("vector4_normalize");
extern fn Vector4 Vector4.min(self, Vector4 v2) @extern("vector4_min");
extern fn Vector4 Vector4.max(self, Vector4 v2) @extern("vector4_max");
extern fn Vector4 Vector4.lerp(self, Vector4 target, float amount) @extern("vector4_lerp");
extern fn Vector4 Vector4.move_towards(self, Vector4 target, float max_distance) @extern("vector4_move_towards");
extern fn Vector4 Vector4.invert(self) @extern("vector4_invert");


const float EPSILON = 1.1920929E-7;

struct Quaternion {
  float x, y, z, w;
}

extern fn bool Quaternion.equals(self, Quaternion rhs) @operator(==) @extern("quaternion_equals");
extern fn Quaternion Quaternion.mul(self, Quaternion rhs) @operator(*) @extern("quaternion_mul");
extern fn Quaternion Quaternion.scale(self, float rhs) @operator_s(*) @extern("quaternion_scale");

extern fn Vector2 Quaternion.v2(self) @extern("quaternion_v2");
extern fn Vector3 Quaternion.v3(self) @extern("quaternion_v3");
extern fn Vector4 Quaternion.v4(self) @extern("quaternion_v4");
extern fn Quaternion Quaternion.to_axis_angle(self) @extern("quaternion_axisangle");

extern fn float Quaternion.length(self) @extern("quaternion_length");
extern fn float Quaternion.length_sqr(self) @extern("quaternion_length_sqr");
extern fn float Quaternion.dot_product(self, Quaternion v2) @extern("quaternion_dot_product");
extern fn Quaternion Quaternion.normalize(self) @extern("quaternion_normalize");
extern fn Quaternion Quaternion.n_lerp(self, Quaternion target, float amount) @extern("quaternion_nlerp");
extern fn Quaternion Quaternion.slerp(self, Quaternion target, float amount) @extern("quaternion_slerp");
extern fn Quaternion Quaternion.to_euler(self) @extern("quaternion_toeuler");
extern fn Quaternion Quaternion.transform(self, Matrix mat) @extern("quaternion_transform");
extern fn Quaternion from_v3_to_v3(Vector3 from, Vector3 to) @extern("quaternion_fromv3tov3");
extern fn Quaternion from_axis_angle(Vector3 axis, float angle) @extern("quaternion_fromaxisangle");
extern fn Quaternion from_euler(float pitch, float yaw, float roll) @extern("quaternion_fromeuler");


module ennoia::yaml;
import std::collections;

alias Object = HashMap{String, TypedValue};
alias Yaml   = HashMap{String, TypedValue};
alias Array  = List{TypedValue};
struct TypedValue {
  YAMLType type;
  union {
    void* as_void;
    bool as_bool;
    int as_int;
    double as_double;
    String as_string;
    Object as_object;
    Array as_array;
  }
}
enum YAMLType {
  NONE,
  INT,
  DOUBLE,
  STRING,
  ARRAY,
  BOOL,
  OBJECT,
}

extern fn usz TypedValue.size(&self) @extern("yaml_tvsize");
extern fn TypedValue TypedValue.get_array(&self, usz index) @extern("yaml_tvarray");
extern fn TypedValue TypedValue.get_object(&self, String name) @extern("yaml_tvobj");
extern fn bool TypedValue.has_key(&self, String key) @extern("yaml_haskey");

extern fn Yaml parse_file(String filename) @extern("yaml_parsefile");
extern fn Yaml parse(String data) @extern("yaml_parse");
extern fn void Yaml.clean(&self) @extern("yaml_clean");
extern fn void Yaml.print(&self) @extern("yaml_print");

