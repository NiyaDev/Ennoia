
module ennoia;

extern Color  bgColor       @extern("bgcolor");
extern double deltaTime     @extern("deltatime");
extern double lastFrame     @extern("lastframe");
extern bool   forceClose    @extern("forceclose");
extern int    renWidth      @extern("renderwidth");
extern int    renHeight     @extern("renderheight");
extern Vec2f  mousePosition @extern("mouseposition");
extern Vec2f  mouseDelta    @extern("mousedelta");
extern float  scrollwheel   @extern("scrollwheel");


extern fn void init(int width = -1, int height = -1, String title = "ENNOIA", float scale = 0) @extern("init");
extern fn void clean() @extern("clean");
extern fn bool window_should_close() @extern("windowshouldclose");
extern fn void set_vertex_attribute(uint location, uint size, void* offset) @extern("set_vertex_attribute");

extern fn void drawing() @extern("drawing");
extern fn void start_drawing() @extern("start_drawing");
extern fn void end_drawing() @extern("end_drawing");

extern fn void clear_background() @extern("clearbg");
extern fn void set_Size(uint w, uint h) @extern("setsize");
extern fn void set_render_scale(float scale) @extern("setrenderscale");
extern fn void set_borderless(bool borderless = true) @extern("setborderless");
extern fn void set_fullscreen(bool fullscreen = true) @extern("setfullscreen");
extern fn void set_fov(float fov) @extern("setfov");
extern fn int get_fps() @extern("getfps");
extern fn int[2] get_display_resolution() @extern("getdisplayresolution");

extern fn void set_shader(Shader newShader) @extern("setshader");
extern fn Shader get_shader() @extern("getshader");


module ennoia::render;
import ennoia::color;
import ennoia::rectangle;
import ennoia::vector;

extern fn void draw_mesh(String nameMesh = "cube", String nameTexture = "", Vec3f position = {}, Vec3f scale = {1,1,1}, Vec3f rotation = {}) @extern("render_mesh");
extern fn void draw_texture(String nameTexture = "default", Rectangle dst = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, Vec3f rotation = {}, Color tint = {255, 255, 255, 255}) @extern("render_texture");


module ennoia::bounds;
import ennoia::vector;

struct BoundingBox {
  Vec3f min, max;
}

extern fn bool check_boxes(BoundingBox b1, BoundingBox b2) @extern("bounds_checkbox");


module ennoia::bulk;
import ennoia::font;
import ennoia::keybinds;
import ennoia::localization;
import ennoia::mesh;
import ennoia::options;
import ennoia::shader;
import ennoia::texture;
import std::collections;
import std::io;

extern const char VERSION_MAJOR @extern("bulk_majorversion");
extern const char VERSION_MINOR @extern("bulk_minorversion");

alias BulkTable = HashMap{String, TableEntry};
struct TableEntry {
  String name;
  ulong length, pointer;
  DataType type;
CompType comp;
}
enum DataType : short {
  EMPTY,
  RAW,
  TEXT,
  KEYBIND,
  OPTION,
  LOCALIZATION,
  
  // OpenGL/SDL3
  TEXTURE,
  FONT,
SHADER,
  MODEL,
  MATERIAL,
}
enum CompType : short {
  NONE,
  DEFLATE,
}

extern fn char[]  load(String filepath, String dataname) @extern("bulk_load");
extern fn void    load_all(String filepath) @extern("bulk_loadall");
extern fn Texture load_texture(String filepath, String dataname, bool send = true) @extern("bulk_texture");
extern fn void    load_all_textures(String filepath) @extern("bulk_alltextures");
extern fn Font    load_font(String filepath, String dataname, bool send = true) @extern("bulk_font");
extern fn void    load_all_font(String filepath) @extern("bulk_allfont");
extern fn HashMap{String, Mesh} load_model(String filepath, String dataname, bool send = true) @extern("bulk_model");
extern fn void    load_all_models(String filepath) @extern("bulk_allmodel");
extern fn Shader  load_shader(String filepath, String dataname, bool send = true) @extern("bulk_shader");
extern fn void    load_all_shaders(String filepath) @extern("bulk_allshader");
extern fn Keybind load_keybind(String filepath, String dataname, bool send = true) @extern("bulk_keybind");
extern fn void    load_all_keybinds(String filepath) @extern("bulk_allkeybind");
extern fn Option  load_option(String filepath, String dataname, bool send = true) @extern("bulk_option");
extern fn void    load_all_options(String filepath) @extern("bulk_alloption");
extern fn Localization load_localization(String filepath, String dataname, bool send = true) @extern("bulk_local");
extern fn void    load_all_localizations(String filepath) @extern("bulk_alllocal");

extern fn bool TableEntry.equals_str(&self, String rhs) @operator_s(==) @extern("tableentry_equals");
extern fn usz TableEntry.size(&self) @extern("tableentry_size");

extern fn String[] get_entries(String filepath) @extern("tableentry_getentries");
extern fn BulkTable get_table(String filepath) @extern("tableentry_gettable");
extern fn TableEntry get_table_entry(String filepath, String dataname) @extern("tableentry_gettableentry");

extern fn short File.read_short(&self) @extern("bulk_fileshort");
extern fn int File.read_int(&self) @extern("bulk_fileint");
extern fn long File.read_long(&self) @extern("bulk_filelong");
extern fn float File.read_float(&self) @extern("bulk_filefloat");
extern fn double File.read_double(&self) @extern("bulk_filedouble");
extern fn String File.read_string(&self) @extern("bulk_filestring");

extern fn void File.write_short(&self, short val) @extern("bulk_filewriteshort");
extern fn void File.write_int(&self, int val) @extern("bulk_filewriteint");
extern fn void File.write_long(&self, long val) @extern("bulk_filewritelong");
extern fn void File.write_float(&self, float val) @extern("bulk_filewritefloat");
extern fn void File.write_double(&self, double val) @extern("bulk_filewritedouble");
extern fn void File.write_string(&self, String val) @extern("bulk_filewritestring");


module ennoia::camera;
import ennoia::matrix;
import ennoia::vector;

struct Camera {
  Vec3f target, distance, up;
  float fov, rotation, rot_target;
}

extern Camera main @extern("camera_main");

extern fn void update(Camera* cam = &main) @extern("camera_update");
extern fn Matrix get_matrix(Camera* cam = &main) @extern("camer_getmatrix");
extern fn void rotate(float target, Camera* cam = &main) @extern("camera_rotate");
extern fn bool is_rotating(Camera* cam = &main) @extern("camera_isrotating");
extern fn void Camera.print(self) @extern("camera_print");


module ennoia::color;
import ennoia::vector;

struct Color {
  char r, g, b, a;
}

const Color LIGHTGRAY		= {200, 200, 200, 255};
const Color GRAY		  	= {130, 130, 130, 255};
const Color DARKGRAY		= { 80,  80,  80, 255};
const Color YELLOW			= {253, 249,   0, 255};
const Color GOLD		  	= {255, 203,   0, 255};
const Color ORANGE	 		= {255, 161,   0, 255};
const Color PINK 				= {255, 109, 194, 255};
const Color RED 				= {230,  41,  55, 255};
const Color MAROON 			= {190,  33,  55, 255};
const Color GREEN 			= {  0, 228,  48, 255};
const Color LIME				= {  0, 158,  47, 255};
const Color DARKGREEN		= {  0, 117,  44, 255};
const Color SKYBLUE			= {102, 191, 255, 255};
const Color BLUE				= {  0, 121, 241, 255};
const Color DARKBLUE		= {  0,  82, 172, 255};
const Color PURPLE			= {200, 122, 255, 255};
const Color VIOLET			= {135,  60, 190, 255};
const Color DARKPURPLE	= {112,  31, 126, 255};
const Color BEIGE				= {211, 176, 131, 255};
const Color BROWN				= {127, 106,  79, 255};
const Color DARKBROWN		= { 76,  63,  47, 255};
const Color WHITE				= {255, 255, 255, 255};
const Color BLACK				= {  0,   0,   0, 255};
const Color BLANK				= {  0,   0,   0,   0};
const Color MAGENTA			= {255,   0, 255, 255};
const Color PALETTE_30	= { 48,  56,  67, 255};


extern fn bool Color.equals(self, Color rhs) @operator(==) @extern("color_equals");

extern fn uint Color.to_int(self) @extern("color_toint");
extern fn Color uint.to_color(self) @extern("color_fromint");
extern fn Vec3f Color.to_hsv(self) @extern("color_tohsv");
extern fn Color Vec3f.to_color(self) @extern("colorfromhsv");
extern fn Vec4f Color.normalize(self) @extern("color_normalize");

extern fn void Color.fade(&self, float alpha) @extern("color_fade");
extern fn Color Color.tint(self, Color tint) @extern("color_tint");
extern fn Color Color.brightness(self, float factor) @extern("color_brightness");
extern fn Color Color.contrast(self, float contrast) @extern("color_contrast");
extern fn Color Color.alpha(self, float alpha) @extern("color_alpha");
extern fn Color Color.multiply(self, float factor) @extern("color_multiply");


module ennoia::font;
import ennoia::color;
import ennoia::rectangle;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Font {
  Texture atlas;
  Vec2f dim;
  HashMap{char, Rectangle} rects;
}

extern fn Font load(String filename, Vec2f size) @extern("font_load");
extern fn Font load_from_mem(char[] data, Vec2f size) @extern("font_loadfrommem");
extern fn void Font.clean(&self) @extern("font_clean");

extern fn void Font.draw(&self, String textIn, Vec2f position = {0,0}, Vec2f scale = {1,1}, float spacing = 0, Color color = color::WHITE) @extern("font_draw");


module ennoia::keybinds;
import std::collections;
import sdl3;

alias KeyboardKey = uint;
alias KeyboardMod = ushort;
alias Keybindings = HashMap{String, Keybind};

struct KeyData {
  KeyboardKey key;
  KeyboardMod mod;
  bool down;
  bool repeat;
}
struct Keybind {
  KeyboardKey key;
  KeyboardMod mod;
}

extern fn void save_keybinds() @extern("keybinds_save");
extern fn void KeyData.print(&self) @extern("keybinds_print");

extern fn void update() @extern("keybinds_update");

extern fn int  queue_contains(SDL_KeyboardEvent data) @export("keybinds_queuecontains");
extern fn void queue_add(SDL_KeyboardEvent data) @extern("keybinds_queueadd");
extern fn void queue_remove(SDL_KeyboardEvent data) @extern("keybinds_queueremove");

extern fn bool pressed(String key) @extern("keybinds_pressed");
extern fn bool down(String key)    @extern("keybinds_down");
extern fn bool up(String key)      @extern("keybinds_up");
extern fn bool mouse_pressed(uint button) @extern("keybinds_mousepressed");
extern fn bool mouse_down(int button)     @extern("keybinds_mousedown");
extern fn bool mouse_up(int button)       @extern("keybinds_mouseup");


module ennoia::localization;
import std::collections;

alias Local = HashMap{String, String};
alias Localization = HashMap{String, Local};

extern fn void Localization.add_assign(&self, Localization* rhs) @operator(+=) @extern("local_add");

extern fn String get(String key) @extern("local_get");
extern fn bool contains(String key) @extern("local_contains");


module ennoia::matrix;
import ennoia::vector;
import std::math;

struct Matrix {
  float m0,  m1,  m2,  m3;
  float m4,  m5,  m6,  m7;
  float m8,  m9,  m10, m11;
  float m12, m13, m14, m15;
}

const Matrix IDENTITY = {
  1,0,0,0,
  0,1,0,0,
  0,0,1,0,
  0,0,0,0,
};

extern fn bool Matrix.equals(self, Matrix rhs) @operator(==) @extern("matrix_equals");
extern fn Matrix Matrix.add(self, Matrix rhs) @operator(+) @extern("matrix_add");
extern fn Matrix Matrix.sub(self, Matrix rhs) @operator(-) @extern("matrix_sub");
extern fn Matrix Matrix.mul(self, Matrix rhs) @operator(*) @extern("matrix_mul");

extern fn float Matrix.determinant(self) @extern("matrix_determinant");
extern fn float Matrix.trace(self) @extern("matrix_trace");
extern fn Matrix Matrix.transpose(self) @extern("matrix_transpose");
extern fn Matrix Matrix.invert(self) @extern("matrix_invert");
extern fn Vec4f Matrix.quaternion_transform(self, Quaternionf q) @extern("matrix_quaterniontransform");
extern fn void Matrix.print(&self) @extern("matrix_print");
extern fn Matrix Matrix.translate(self, Vec3f v) @extern("matrix_translate");
extern fn Matrix rotate_x(float angle) @extern("matrix_rotatex");
extern fn Matrix rotate_y(float angle) @extern("matrix_rotatey");
extern fn Matrix rotate_z(float angle) @extern("matrix_rotatez");
extern fn Matrix Matrix.rotate(&self, Vec3f angle) @extern("matrix_rotatexyz");
extern fn Matrix rotate_zyx(Vec3f angle) @extern("matrix_rotatezyx");
extern fn Matrix Matrix.scale(self, Vec3f scale) @extern("matrix_scale");
extern fn Matrix frustum(double left, double right, double bottom, double top, double near_plane, double far_plane) @extern("matrix_frustum");
extern fn Matrix perspective(double fov_y, double aspect, double near_plane, double far_plane) @extern("matrix_perspective");
extern fn Matrix ortho(double left, double right, double bottom, double top, double near_plane, double far_plane) @extern("matrix_");
extern fn Matrix look_at(Vec3f eye, Vec3f target, Vec3f up) @extern("matrix_lookat");


module ennoia::mesh;
import ennoia::matrix;
import ennoia::shader;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Mesh {
  Vertex[] vertices;
  Indices[] indices;

  uint vao, vbo, ebo;

  Shader shader;
  String materialName;
  Texture* texture;
}

struct Vertex {
  Vec3f position;
  Vec3f normal;
  Vec2f texCoords;
  Vec4f color;
}
alias Indices = uint[3];

extern fn HashMap{String, Mesh} load_from_mem(String data) @extern("mesh_loadfrommem");
extern fn void Mesh.clean(&self) @extern("mesh_cleanmesh");

extern fn Mesh new(Vertex[] vertices = {}) @extern("mesh_new");
extern fn Mesh gen_tri(float width, float height) @extern("mesh_gentri");
extern fn Mesh gen_quad() @extern("mesh_genquad");
extern fn Mesh gen_cube(float width, float height, float depth) @extern("mesh_gencube");

extern fn void Mesh.upload(&self) @extern("mesh_upload");
extern fn void Mesh.delete(&self) @extern("mesh_delete");

extern fn void Mesh.update_positions(&self, Vec3f[] newPos) @extern("mesh_updatepositions");
extern fn void Mesh.update_normals(&self, Vec3f[] newNorms) @extern("mesh_updatenormals");
extern fn void Mesh.update_texcoords(&self, Vec2f[] newCoords) @extern("mesh_updatetexcoords");
extern fn void Mesh.update_colors(&self, Vec4f[] newColors) @extern("mesh_updatecolors");

extern fn void Mesh.draw(&self, Vec3f position = {}, Vec3f scale = {1,1,1}, Vec3f rotation = {}, Texture* texture = null) @extern("mesh_draw");
extern fn void Mesh.draw_instanced(&self, Matrix[] mats) @extern("mesh_drawinstanced");
extern fn void Mesh.draw_2d(&self, Vec2f position = {}, Vec2f scale = {1,1}, float rotation = 0, Texture* texture = null) @extern("mesh_draw2d");

extern fn void Vertex.print(&self) @extern("mesh_print");


module ennoia::options;
import std::collections;

alias Options = HashMap{String, Option};

struct Option {
  OptionType type;
  OptionData data;
}
union OptionData {
  char as_char;
  short as_short;
  int as_int;
  long as_long;

  float as_float;
  double as_double;

  String as_string;
}
enum OptionType : char {
  CHAR,
  SHORT,
  INT,
  LONG,

  FLOAT,
  DOUBLE,

  STRING,
}

extern fn char get_char(String optname) @extern("options_char");
extern fn short get_short(String optname) @extern("options_short");
extern fn int get_int(String optname) @extern("options_int");
extern fn long get_long(String optname) @extern("options_long");
extern fn float get_float(String optname) @extern("options_float");
extern fn double get_double(String optname) @extern("options_double");

extern fn void set_char(String optname) @extern("options_setchar");
extern fn void set_short(String optname) @extern("options_setshort");
extern fn void set_int(String optname) @extern("options_setint");
extern fn void set_long(String optname) @extern("options_setlong");
extern fn void set_float(String optname) @extern("options_setfloat");
extern fn void set_double(String optname) @extern("options_setdouble");

extern fn bool contains(String optname) @extern("options_contains");

extern fn void save() @export("options_save");


module ennoia::rectangle;
import ennoia::vector;

struct Rectangle {
  float x, y, w, h;
}

extern fn bool Rectangle.equals(self, Rectangle rhs) @operator(==) @extern("rect_equals");
extern fn Rectangle Rectangle.add(self, Rectangle rhs) @operator(+) @extern("rect_add");
extern fn Rectangle Rectangle.add_v2(self, Vec2f rhs) @operator_s(+) @extern("rect_addv2");
extern fn Rectangle Rectangle.add_v4(self, Vec4f rhs) @operator_s(+) @extern("rect_addv4");
extern fn Rectangle Rectangle.sub(self, Rectangle rhs) @operator(-) @extern("rect_sub");
extern fn Rectangle Rectangle.sub_v2(self, Vec2f rhs) @operator_s(-) @extern("rect_subv2");
extern fn Rectangle Rectangle.mul(self, Rectangle rhs) @operator(*) @extern("rect_mul");
extern fn Rectangle Rectangle.mul_v2(self, Vec2f rhs) @operator_s(*) @extern("rect_mulv2");
extern fn Rectangle Rectangle.div(self, Rectangle rhs) @operator(/) @extern("rect_div");
extern fn Rectangle Rectangle.div_v2(self, Vec2f rhs) @operator_s(/) @extern("rect_divv2");

extern fn Vec2f Rectangle.v2(self) @extern("rect_v2");
extern fn Vec4f Rectangle.v4(self) @extern("rect_v4");

extern fn bool Rectangle.within(self, Vec2f rhs) @extern("rect_within");


module ennoia::shader;
import ennoia::matrix;
import ennoia::texture;
import ennoia::vector;
import std::collections;

struct Shader {
  uint id;
  HashMap{String,uint} locs;
}

extern fn Shader load(String vert, String frag) @extern("shader_load");
extern fn Shader compile(char[] vert = {}, char[] frag = {}) @extern("shader_compile");
extern fn void Shader.clean(&self) @extern("shader_clean");
extern fn void Shader.use(&self) @extern("shader_use");

extern fn void Shader.set_int(&self, String name, int i) @extern("shader_setint");
extern fn void Shader.set_float(&self, String name, float f) @extern("shader_setfloat");
extern fn void Shader.set_vec2f(&self, String name, Vec2f v2) @extern("shader_setv2");
extern fn void Shader.set_vec4f(&self, String name, Vec4f v4) @extern("shader_setv4");
extern fn void Shader.set_matrix(&self, String name, Matrix mat) @extern("shader_setmat");
extern fn void Shader.set_texture(&self, String name, Texture texture) @extern("shader_settexture");


module ennoia::texture;
import ennoia::color;
import ennoia::rectangle;

struct Texture {
  uint id;
  uint width, height;
  int mipmaps;
  int format;
  bool transparency;
}
enum TilingLayout {
  THREE_THREE,
  ONE_THREE,
  THREE_ONE,
}

extern fn Texture load(String filename) @extern("texture_load");
extern fn Texture load_from_mem(char[] dat) @extern("texture_loadfrommem");
extern fn Texture new(int width, int height) @extern("texture_new");
extern fn void Texture.clean(&self) @extern("texture_clean");

extern fn void Texture.draw(&self, Rectangle dst = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, Color color = color::WHITE) @extern("texture_draw");
extern fn void Texture.draw_tiled(&self, Rectangle dest = {0,0,-1,-1}, Rectangle src = {0,0,-1,-1}, TilingLayout layout = THREE_THREE, Color color = color::WHITE) @extern("texture_drawtiled");


module ennoia::ui;
import ennoia::color;
import ennoia::rectangle;
import ennoia::vector;

alias Element = void;
alias FuncCallVoid = fn void();
enum ElementType {
  EMPTY,

  LABEL,
  BUTTON,
  BAR,

  CONTAINER_VERT,
  CONTAINER_HORI,
}
enum TextAlignmentHorizontal {
  RIGHT,
  CENTER,
  LEFT,
}
enum TextAlignmentVertical {
  TOP,
  CENTER,
  BOTTOM,
}

extern fn void add(String name, Element* e) @extern("ui_add");
extern fn bool exists(String name) @extern("ui_exists");
extern fn Element* get(String name) @extern("ui_get");

extern fn Element* new_label(String text = "NULL", long duration = 0, String font = "font", float spacing = 0, Color tint = color::WHITE, Vec2f position = {0,0}, Vec2f scale = {1,1}) @extern("ui_label");
extern fn Element* new_button(String text = "NULL", long duration = 0, String font = "font", float spacing = 0, Color textTint = color::WHITE, String texture = "texture", Color[3] textureTint = {{255, 255, 255, 255}, color::LIGHTGRAY, color::DARKGRAY}, Rectangle bounds = {0,0,64,16}, Vec4f textPadding = {2,2,2,2}, Vec2f scale = {1,1}, TextAlignmentHorizontal alignHori = CENTER, TextAlignmentVertical alignVert = CENTER, bool active = true, FuncCallVoid hover = null, FuncCallVoid click = null) @extern("ui_button");
extern fn Element* new_container(ElementType container = CONTAINER_VERT, long duration = 0, Rectangle bounds = {0,0,16,16}, Vec2f scale = {1,1}, Vec4f offset = {2,2,2,2}, float spacing = 0, String texture = "", Element*[] elements = {}) @extern("ui_container");


module ennoia::ui::imm;
import ennoia::color;
import ennoia::rectangle;
import ennoia::vector;

extern fn void label(String text = "", String font = "font", float spacing = 0, Color tint = {255, 255, 255, 255}, Vec2f position = {0,0}, Vec2f scale = {1,1}, int priority = 0) @extern("imm_label");
extern fn void texture(String texture = "texture", Color tint = color::WHITE, Rectangle bounds = {0,0,64,16}, int priority = 0) @extern("imm_texture");
extern fn void texture_tiled(String texture = "texture", Color tint = color::WHITE, Rectangle bounds = {0,0,64,16}, Vec2f scale = {1,1}, int priority = 0) @extern("imm_texturetiled");
extern fn bool button(String text = "", String font = "font", float spacing = 0, Color textTint = {255, 255, 255, 255}, Vec2f textScale = {1,1}, String texture = "", Color[3] textureTint = {{255, 255, 255, 255},color::LIGHTGRAY,color::DARKGRAY}, Rectangle bounds = {0,0,64,16}, Vec2f textureScale = {1,1}, int priority = 0) @extern("imm_button");
extern fn void bar(String text = "", String font = "font", float spacing = 0, Color textTint = {255, 255, 255, 255}, Vec2f textScale = {1,1}, String textureBg = "", String textureFg = "", Color textureTint = {255, 255, 255, 255}, Rectangle bounds = {0,0,64,16}, Vec2f textureScale = {1,1}, int priority = 0, float* value = null, float* valueMax = null) @extern("imm_bar");

extern fn void container_drag(Vec2f* position, Rectangle dragArea = {0,0,32,8}) @extern("imm_contdrag");


module ennoia::vector;
import ennoia::color;
import ennoia::matrix;
import std::math;

alias Vec2f = float[<2>];
alias Vec2i = int[<2>];

extern fn float Vec2f.angle_rad(self, Vec2f v2) @extern("vector2_angle_rad");
extern fn float Vec2f.angle_deg(self, Vec2f v2) @extern("vector2_angle_deg");
extern fn Vec2f Vec2f.lerp(self, Vec2f v2, float amount) @extern("vector2_lerp");
extern fn Vec2f Vec2f.reflect(self, Vec2f normal) @extern("vector2_reflect");
extern fn Vec2f Vec2f.rotate_rad(self, float angle) @extern("vector2_rotate_rad");
extern fn Vec2f Vec2f.rotate_deg(self, float angle) @extern("vector2_rotate_deg");
extern fn Vec2f Vec2f.move_towards(self, Vec2f target, float max_distance) @extern("vector2_move_toward");
extern fn Vec2f Vec2f.invert(self) @extern("vector2_invert");
extern fn Vec2f Vec2f.clamp(self, Vec2f min, Vec2f max) @extern("vector2_clamp");
extern fn Vec2f Vec2f.clamp_mag(self, float min, float max) @extern("vector2_clamp_mag");


alias Vec3f = float[<3>];
alias Vec3i = int[<3>];

extern fn Color Vec3f.color(self) @extern("vector3_color");
extern fn float Vec3f.cross_product(self, Vec3f v2) @extern("vector3_cross_product");
extern fn float Vec3f.angle_rad(self, Vec3f v2) @extern("vector3_angle_rad");
extern fn float Vec3f.angle_deg(self, Vec3f v2) @extern("vector3_angle_deg");
extern fn Vec3f Vec3f.normalize(self) @extern("vector3_normalize");
extern fn Vec3f Vec3f.project(self, Vec3f v2) @extern("vector3_project");
extern fn Vec3f Vec3f.reject(self, Vec3f v2) @extern("vector3_reject");
extern fn void Vec3f.orthonormalize(&self, Vec3f* v2) @extern("vector3_orthonormalize");
extern fn Vec3f Vec3f.rotate_quaternion(self, Quaternionf q) @extern("vector3_rotate_q");
extern fn Vec3f Vec3f.rotate(self, Vec3f dist, float rot) @extern("vector3_rotate");
extern fn Vec3f Vec3f.move_towards(self, Vec3f target, float max_distance) @extern("vector3_move_towards");
extern fn Vec3f Vec3f.lerp(self, Vec3f target, float amount) @extern("vector3_lerp");
extern fn Vec3f Vec3f.reflect(self, Vec3f normal) @extern("vector3_reflect");
extern fn Vec3f Vec3f.min(self, Vec3f v2) @extern("vector3_min");
extern fn Vec3f Vec3f.max(self, Vec3f v2) @extern("vector3_max");
extern fn Vec3f Vec3f.invert(self) @extern("vector3_invert");
extern fn Vec3f Vec3f.clamp(self, Vec3f min, Vec3f max) @extern("vector3_clamp");
extern fn Vec3f Vec3f.clamp_mag(self, float min, float max) @extern("vector3_clamp_mag");
extern fn bool float.close(self, float f2, float amount) @extern("float_close");
extern fn bool Vec3f.close(self, Vec3f v2, float amount) @extern("vector3_close");


alias Vec4f = float[<4>];
alias Vec4i = int[<4>];

extern fn Color Vec4f.color(self) @extern("vector4_color");

extern fn Vec4f Vec4f.min(self, Vec4f v2) @extern("vector4_min");
extern fn Vec4f Vec4f.max(self, Vec4f v2) @extern("vector4_max");
extern fn Vec4f Vec4f.lerp(self, Vec4f target, float amount) @extern("vector4_lerp");
extern fn Vec4f Vec4f.move_towards(self, Vec4f target, float max_distance) @extern("vector4_move_towards");
extern fn Vec4f Vec4f.invert(self) @extern("vector4_invert");


const float EPSILON = 1.1920929E-7;


module ennoia::yaml;
import std::collections;

alias Object = HashMap{String, TypedValue};
alias Yaml   = HashMap{String, TypedValue};
alias Array  = List{TypedValue};
struct TypedValue {
  YAMLType type;
  union {
    void* as_void;
    bool as_bool;
    int as_int;
    double as_double;
    String as_string;
    Object as_object;
    Array as_array;
  }
}
enum YAMLType {
  NONE,
  INT,
  DOUBLE,
  STRING,
  ARRAY,
  BOOL,
  OBJECT,
}

extern fn usz TypedValue.size(&self) @extern("yaml_tvsize");
extern fn TypedValue TypedValue.get_array(&self, usz index) @extern("yaml_tvarray");
extern fn TypedValue TypedValue.get_object(&self, String name) @extern("yaml_tvobj");
extern fn bool TypedValue.has_key(&self, String key) @extern("yaml_haskey");

extern fn Yaml parse_file(String filename) @extern("yaml_parsefile");
extern fn Yaml parse(String data) @extern("yaml_parse");
extern fn void Yaml.clean(&self) @extern("yaml_clean");
extern fn void Yaml.print(&self) @extern("yaml_print");

